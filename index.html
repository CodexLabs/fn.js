<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8' />
    <meta http-equiv="X-UA-Compatible" content="chrome=1" />
    <meta name="description" content="fn.js : Functional programming strategy library for JavaScript" />

    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">

    <title>fn.js</title>
  </head>

  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
          <a id="forkme_banner" href="https://github.com/eliperelman/fn.js">View on GitHub</a>

          <h1 id="project_title">fn.js</h1>
          <h2 id="project_tagline">Functional programming strategy library for JavaScript</h2>

            <section id="downloads">
              <a class="zip_download_link" href="https://github.com/eliperelman/fn.js/zipball/master">Download this project as a .zip file</a>
              <a class="tar_download_link" href="https://github.com/eliperelman/fn.js/tarball/master">Download this project as a tar.gz file</a>
            </section>
        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">
        <h1>
<a name="fnjs" class="anchor" href="#fnjs"><span class="octicon octicon-link"></span></a>fn.js</h1>

<p><code>fn.js</code> is a library that forms a strategy for functional programming in JavaScript. This library differs from other similar libraries you may be used to as it strives to achieve purer adherence to functional programming tenets.</p>

<pre><code>NOTE: This project is in early stages and may undergo breaking changes
while we work to make it much more robust and feature complete.
</code></pre>

<h2>
<a name="installation" class="anchor" href="#installation"><span class="octicon octicon-link"></span></a>Installation</h2>

<p><code>fn.js</code> is a UMD module, so it can be used in the browser, Node.js, and AMD/require.js environments.</p>

<h4>
<a name="nodejs" class="anchor" href="#nodejs"><span class="octicon octicon-link"></span></a>Node.js</h4>

<div class="highlight highlight-sh"><pre>npm install fn.js
</pre></div>

<div class="highlight highlight-js"><pre><span class="kd">var</span> <span class="nx">fn</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">'fn.js'</span><span class="p">);</span>
</pre></div>

<h4>
<a name="amd-requirejs" class="anchor" href="#amd-requirejs"><span class="octicon octicon-link"></span></a>AMD require.js</h4>

<div class="highlight highlight-js"><pre><span class="nx">require</span><span class="p">.</span><span class="nx">config</span><span class="p">({</span>
    <span class="nx">paths</span><span class="o">:</span> <span class="p">{</span>
        <span class="nx">fn</span><span class="o">:</span> <span class="s1">'path/to/fn'</span>
    <span class="p">}</span>
<span class="p">});</span>
</pre></div>

<div class="highlight highlight-js"><pre><span class="nx">define</span><span class="p">([</span><span class="s1">'fn'</span><span class="p">],</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">fn</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// fn now available</span>
<span class="p">};</span>
</pre></div>

<h4>
<a name="traditional-browser-script-include" class="anchor" href="#traditional-browser-script-include"><span class="octicon octicon-link"></span></a>Traditional browser script include</h4>

<div class="highlight highlight-html"><pre><span class="nt">&lt;script </span><span class="na">src=</span><span class="s">"path/to/fn.js"</span><span class="nt">&gt;&lt;/script&gt;</span>
<span class="nt">&lt;script&gt;</span>
    <span class="c1">// fn now available</span>
<span class="nt">&lt;/script&gt;</span>
</pre></div>

<h2>
<a name="functional-programming" class="anchor" href="#functional-programming"><span class="octicon octicon-link"></span></a>Functional Programming</h2>

<p>Functional programming, as opposed to imperative programming, is a programming paradigm where the flow of an application's code is directed by functions, not objects or procedures. If it helps, you may try to imagine functional programming as the opposite of object-oriented programming even though the parallels are not completely one-to-one.</p>

<p>Functional programming often involves creating abstractions through several layers of functions or function passing. Functional programming is often not more performant, but rather writing code becomes more efficient. Expressions can be written in a much more elegant and terse manner. Functional programming strives to employ some core tenets:</p>

<h3>
<a name="referential-transparency" class="anchor" href="#referential-transparency"><span class="octicon octicon-link"></span></a>Referential Transparency</h3>

<p>In object-oriented or classic programming applications, the flow of code is controlled by creating objects that mimic real-world or virtual beings. As an example, if you were creating an application that allowed users to purchase a vehicle, you might create a <code>Vehicle</code> class or prototype to model the interaction that a user performs in customizing their vehicle. As a <code>Vehicle</code> instance is modified, other functionality in an application is triggered to execute, and so continues the flow.</p>

<p>In order to control the flow of the program, you must modify the state of objects or the state of an application. Different outcomes are possible based on the state of those objects or the application. In this manner, we can say that object-orientation lacks <em>referential transparency</em>.</p>

<p><em>Referential transparency</em> is the ability of code to be evaluated in a predictable manner, not influenced by external state. Code that has achieved referential transparency is only affected by arguments that are passed to it, and changing state in the application has no effect. That same code should always output the same value for a given set of arguments, and only changing those arguments can a value be different.</p>

<p>In object-orientation, changing the state of the <code>Vehicle</code> can change how functionality on the rest of the site works. In functional programming, we create functions that reads nothing external, only arguments passed to it.</p>

<p>Compare the following functions:</p>

<div class="highlight highlight-js"><pre><span class="kd">var</span> <span class="nx">now</span> <span class="o">=</span> <span class="nb">Date</span><span class="p">.</span><span class="nx">now</span><span class="p">();</span>

<span class="kd">var</span> <span class="nx">getLater</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span> <span class="nx">offset</span> <span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">now</span> <span class="o">+</span> <span class="nx">offset</span><span class="p">;</span>
<span class="p">};</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span> <span class="nx">getLater</span><span class="p">(</span> <span class="mi">15000</span> <span class="p">)</span> <span class="p">);</span> <span class="c1">// invocation</span>
</pre></div>

<div class="highlight highlight-js"><pre><span class="kd">var</span> <span class="nx">getLater</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span> <span class="nx">start</span><span class="p">,</span> <span class="nx">offset</span> <span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">start</span> <span class="o">+</span> <span class="nx">offset</span><span class="p">;</span>
<span class="p">};</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span> <span class="nx">getLater</span><span class="p">(</span> <span class="nb">Date</span><span class="p">.</span><span class="nx">now</span><span class="p">(),</span> <span class="mi">15000</span> <span class="p">)</span> <span class="p">);</span> <span class="c1">// invocation</span>
</pre></div>

<p>In the first snippet, the <code>getLater</code> function accepts a single argument, but depends on external state from the <code>now</code> variable in order to properly operate. The second accepts both values as arguments, and so has no external dependency on state. #1 lacks referential transparency while #2 achieves it. By looking only at the invocation of <code>getLater</code> in each example, you cannot reliably predict the outcome of #1, while you can with #2.</p>

<p>Functional programming inherently tries to avoid making decisions based on state or mutable data that exists external to a function.</p>

<h3>
<a name="higher-order-functions" class="anchor" href="#higher-order-functions"><span class="octicon octicon-link"></span></a>Higher-order Functions</h3>

<p>Functional programming is made possible through the use of higher-order functions. A higher-order function is a function that can <em>accept</em> functions as arguments, and can even <em>return</em> a function.</p>

<p>Higher-order functions facilitate interesting techniques:</p>

<ol>
<li>Strategy pattern through <em>composition</em>
</li>
<li>
<em>Application</em> and <em>currying</em>
</li>
<li><em>Recursion</em></li>
<li>Operator and Mathematical <em>computation</em>
</li>
<li>Visitor pattern through <em>folding</em>
</li>
</ol><h3>
<a name="immutability" class="anchor" href="#immutability"><span class="octicon octicon-link"></span></a>Immutability</h3>

<p>Another core tenant of functional programming is <em>immutability</em>, or the inability for variables to changes their values once created. In other words, all things created should strive to be constants. In JavaScript there is no internal mechanism to enforce this as there is in pure functional programming languages like Haskell and friends. JavaScript is dynamic and without strict typing, and so keeping variables immutable in a codebase is merely a convention and cannot be enforced by fn.js. With that being said, fn.js strives to adhere to this rule and all methods used should treat all arguments passed as immutable. For example, using <code>.map</code> or <code>.reverse</code> will give you back new arrays, not mutate your existing arrays.</p>

<h3>
<a name="side-effects" class="anchor" href="#side-effects"><span class="octicon octicon-link"></span></a>Side Effects</h3>

<p>The concept of side effects is closely related to the design pattern of the Single Responsibility Principle, or as I like to say: "A function should do one thing, and do it well." Any function that does something other than its single intended purpose is said to have <em>side effects</em>. In pure functional programming languages side effects are not allowed, but this is JavaScript and everything is fair game and must be enforced with conventions. For example, take the following method:</p>

<div class="highlight highlight-javascript"><pre><span class="kd">var</span> <span class="nx">add</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">num1</span><span class="p">,</span> <span class="nx">num2</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">num1</span> <span class="o">+</span> <span class="nx">num2</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>

<p>This <code>add</code> method takes 2 numbers and adds them together, and it only does its single purpose; it has no side effects. Now:</p>

<div class="highlight highlight-javascript"><pre><span class="kd">var</span> <span class="nx">add</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">num1</span><span class="p">,</span> <span class="nx">num2</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">num1</span> <span class="o">+</span> <span class="nx">num2</span><span class="p">;</span>

    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">result</span><span class="p">);</span>

    <span class="k">return</span> <span class="nx">result</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>

<p>Here the <code>add</code> method decides to log the results of the addition before returning the result. While the function still achieves its primary purpose, it is no longer free from side effects as it also logs a value in additional to trying to accomplish its goal.</p>

<p>Side effects and state mechanisms should be solved through other means of functional programming, e.g. monads.</p>

<h2>
<a name="coding-guide" class="anchor" href="#coding-guide"><span class="octicon octicon-link"></span></a>Coding Guide</h2>

<p>Any code committed to this library must be evaluated for its adherence to referential transparency and efficient use of higher-order functions. As such, all external contributions must be made through pull request to facilitate the discussion around any new inclusions. Some functions by nature directly violate or bend referential transparency, so it is not always possible to adhere to this principle in every case, and exceptions can be made in those cases.</p>
      </section>
    </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        <p class="copyright">fn.js maintained by <a href="https://github.com/eliperelman">eliperelman</a></p>
        <p>Published with <a href="http://pages.github.com">GitHub Pages</a></p>
      </footer>
    </div>

    

  </body>
</html>
